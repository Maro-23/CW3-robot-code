from roboticstoolbox import Bicycle, RandomPath, VehicleIcon,RangeBearingSensor,LandmarkMap
from math import pi , atan2
import numpy as np
import matplotlib.image as mpimg
import matplotlib.pyplot as plt

initial_position = [-40,40]
anim = VehicleIcon('car', scale=5)
veh = Bicycle(
 animation=anim,
 control=RandomPath,
 dim=500,
 x0 = [-40,40,0]
 )
veh.init(plot=True)

goal=[-20,-40];
goal_marker_style = {
 'marker': 'D',
 'markersize': 6,
 'color': 'b',
}

plt.plot(goal[0], goal[1], **goal_marker_style)

map = LandmarkMap(40,50)

sensor=RangeBearingSensor(robot=veh,map=map,animate=True)
map.plot()
image = mpimg.imread("projectmap.png")
plt.imshow(image, extent = [-50,50,-50,50])
print("Sensor readings: ", sensor.h(veh.x))

distance = [sensor.h(veh.x)[i][0] for i in range(len(sensor.h(veh.x)))]
angle = [sensor.h(veh.x)[i][1] for i in range(len(sensor.h(veh.x)))]
print(distance)
print(angle)


goal_arr=[[37,0],[-15,-15]]
goal_arr.append(goal)
goal_arr.insert(0,initial_position)

for i in range(len(goal_arr)):
    run = True
    goal = [goal_arr[i][0],goal_arr[i][1]]
    while(run):
        goal_heading = atan2((goal[1] - veh.x[1]),(goal[0] - veh.x[0]))
      
        steer = goal_heading-veh.x[2]
        if steer>pi:
            steer = steer-2*pi
        veh.step(4,steer)
        if( (abs(goal[0]-veh.x[0]) >0.3) or (abs(goal[1]-veh.x[1]) > 0.3) ):
            run=True
        else:
            run=False
        veh._animation.update(veh.x)
        plt.pause(0.0005)
    
plt.pause(10)






#run = True
#while(run):
#    distance = [sensor.h(veh.x)[i][0] for i in range(len(sensor.h(veh.x)))]
#   angle = [sensor.h(veh.x)[i][1] for i in range(len(sensor.h(veh.x)))]
#    veh.step(5,-0.1)
#    if min(distance) < 3 or abs(min(angle)) < pi/4:
#        run = False
#    veh._animation.update(veh.x)
#    plt.pause(0.005)
plt.pause(100)

